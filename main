import pandas as pd
from sklearn.cluster import KMeans
from sklearn import feature_selection
from sklearn.feature_selection import SelectKBest, f_regression, f_classif

execfile("music-to-vec.py")

# Import first genre
# Only import music of one particular genre here. In other words, do not upload both pop AND classical music, just choose one.
from google.colab import files
uploaded = files.upload()

# FIRST GENRE
names = []
for i in range(len(uploaded.keys())):
  names.append(str(uploaded.keys()[i]))
  
# Get State Matrices for each piece
sm = []
for n in range(len(names)):
  sm.append(midiToNoteStateMatrix(names[n]))

sm1 = []
names1 = []
for song in range(len(sm)):
  if len(sm[song]) != 1:
    sm1.append(sm[song])
    names1.append(names[song])
    
first_genre = ['classical'] * len(names1)
first_set = dict(zip(names1,first_genre))

# Import second genre
# Only import music of one particular genre here. In other words, do not upload both pop AND classical music, just choose one.
from google.colab import files
uploaded2 = files.upload()

# SECOND GENRE
names = []
for i in range(len(uploaded2.keys())):
  names.append(str(uploaded2.keys()[i]))
  
# Get State Matrices for each piece
sm = []
for n in range(len(names)):
  sm.append(midiToNoteStateMatrix(names[n]))

sm2 = []
names2 = []
for song in range(len(sm)):
  if len(sm[song]) != 1:
    sm2.append(sm[song])
    names2.append(names[song])
    
second_genre = ['jazz'] * len(names2)
second_set = dict(zip(names2,second_genre))

# Import third genre
# Only import music of one particular genre here. In other words, do not upload both pop AND classical music, just choose one.
from google.colab import files
uploaded3 = files.upload()

# THIRD GENRE
names = []
for i in range(len(uploaded3.keys())):
  names.append(str(uploaded3.keys()[i]))
  
# Get State Matrices for each piece
sm = []
for n in range(len(names)):
  sm.append(midiToNoteStateMatrix(names[n]))

sm3 = []
names3 = []
for song in range(len(sm)):
  if len(sm[song]) != 1:
    sm3.append(sm[song])
    names3.append(names[song])
    
third_genre = ['pop'] * len(names3)
third_set = dict(zip(names3,third_genre))

# CREATE INPUTS FOR KMEANS

final_cluster_input_1 = make_final_inputs(sm1)
final_cluster_input_2 = make_final_inputs(sm2)
final_cluster_input_3 = make_final_inputs(sm3)

#i = [0,0,1,1,1,1,1,1,1,1] # Change this depending on features you want to use
i = [0,0,0,0,0,0,0,1,1,0]
cluster_vec1 = make_final_inputs_vec(final_cluster_input_1,i)
cluster_vec2 = make_final_inputs_vec(final_cluster_input_2,i)
cluster_vec3 = make_final_inputs_vec(final_cluster_input_3,i)

final_input = cluster_vec1 + cluster_vec2 + cluster_vec3
song_names = first_set.keys() + second_set.keys() + third_set.keys()
song_genres = first_set.values() + second_set.values() + third_set.values()

# K-MEANS CLUSTERING

kmeans = KMeans(n_clusters=3)
kmeans.fit(np.array(final_input))

# Array with labels for e/a point we labeled when training the model
mylabels = kmeans.labels_
print(mylabels)
# Need to get new points 
# kmeans.predict(new_points)

print(song_names)

# Assessing Accuracy

# create df of songs, labels, correct labels
output = pd.DataFrame(
    {'file_name': song_names,
     'genre': song_genres,
     'label': mylabels
    })

# create genre labels from numerical labels generated by k-means

temp = ["blank"] * len(output)
output['label_genre'] = temp

# assign 0 label to 1st genre
output.loc[output.label == 0,'label_genre'] = "classical"

# assign 1 label to 2nd genre
output.loc[output.label == 2,'label_genre'] = 'jazz'

# assign 2 label to 3rd genre
output.loc[output.label == 1,'label_genre'] = 'pop'

print(correct(output))
print(incorrect(output))
print(get_accuracy_by_genre(output, 'classical'))
print(get_accuracy_by_genre(output, 'jazz'))
print(get_accuracy_by_genre(output, 'pop'))

# SELECTING FEATURES

# Make a binary string representing the genres
# Needs to be in this form when selecting features

song_bi = [0]*len(song_genres)
for i in range(len(song_genres)):
  if song_genres[i] == 'classical':
    song_bi[i] = 1
  elif song_genres[i] == 'jazz':
    song_bi[i] = 2
    
# Score the 8 1-D features (i = [0,0,1,1,1,1,1,1,1,1])
featureSelector = SelectKBest(score_func=f_classif,k=3)
myfit = featureSelector.fit(final_input,song_bi)

# Put feature names into a list
feature_names = ['Total Number of Plays', 'Total Number of Articulations', \
                'Total Number of Plays and Articulations', 'Avg Plays per Timestep', \
                 'Avg Arts. per Timestep', 'Avg Play and Art. per Timestep', \
                 'Zero Count', 'Length of Songs']

# Create a table with feature names and their respective F-scores
scores_table = pd.DataFrame(
    {'FEATURE': feature_names,
     'F-SCORE': myfit.scores_,
     'p': myfit.pvalues_
    })

scores_table = scores_table[['FEATURE','F-SCORE','p']]

print(scores_table.sort_values(by='F-SCORE',ascending=False))
